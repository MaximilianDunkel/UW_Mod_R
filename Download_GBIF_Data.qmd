---
title: "Download_GBIF-Data"
author: "Max"
format: pdf
editor: visual
---

# GBIF-Daten mit R herunterladen
Geht das auch ohne Login?

Erstmal mit Login:
```{r, "Libraries und Setup"}
#| eval: true
#| echo: true
#| warning: false

#Libraries:
library(rgbif) # für download/datenbeschaffung
library(dplyr) #für df und aufräumen
library(sf) # für umwandlung in räumliche daten und export (geojson)
library(leaflet) # für Visualisierung

#Working directory:
setwd("~/CAU-Zeug/UGM/B-Bereich/Umweltmodellierung/Projekt_Hobby/UW_Mod_R")

```

usageKey und andere Infos zu den gewünschten Daten abgreifen:
```{r, "Infos zu Daten"}
#| eval: true
#| echo: true
#| warning: false

#Das soll die GBIF interne ID der Art beschaffen
usageKey_Species <- rgbif::name_backbone(name = "Amanita phalloides")
usageKey_Species$usageKey

# Fragt die Datensätze nach den folgenden Kriterien ab
data_info <- occ_search(taxonKey = usageKey_Species$usageKey, 
                        year = '2020, 2025',
                        hasCoordinate = TRUE,
                        country = 'DE',
                        hasGeospatialIssue = FALSE,
                        basisOfRecord = 'HUMAN_OBSERVATION',
                        )

data_info$meta$count #Gibt die Menge der "verfügbaren" Datensätze nach den Kriterien wieder.
```


Download der Daten:
```{r, "Download GBIF-Daten"}
#| eval: true
#| echo: true
#| warning: false

# Laut Copilot heißt das "Paging", also die Datenbank, Seite für Seite durchgehen. 
# Ich würde einen for-Loop nehmen. Geht aber bestimmt auch anders

limit <- 500 # maximale Menge Daten, die in einem Rutsch abgegriffen werden können
total <- data_info$meta$count # Die Menge der abgefragten Daten
pages <- ceiling(total/limit) # Die Anzahl der nötigen Zugriffe, bis alle Daten abgesammelt wurden

data_gesammelt <- list()  # Noch leere Liste, die später mit den Seiten gefüllt wird

for (seite in seq_len(pages)) {
  start <- (seite -1)* limit
  cat("Sammle Seite ", seite, "von", pages, "...\n")
  
  data_abfrage <- rgbif::occ_search(taxonKey = usageKey_Species$usageKey, 
                        year = '2020, 2025',
                        hasCoordinate = TRUE,
                        country = 'DE',
                        hasGeospatialIssue = FALSE,
                        basisOfRecord = 'HUMAN_OBSERVATION',
                        limit = limit,
                        start = start
                        )
  
  data_gesammelt[[seite]] <- data_abfrage$data #die einzelnen Seiten liegen jetzt als separate DFs in der Liste, muss jetzt noch zusammengefügt werden (also zu einem einzigen DF)
  data_gesammelt[[seite]] <- dplyr::select(data_abfrage$data,
  occurrenceID, scientificName, decimalLatitude, decimalLongitude, eventDate, year, institutionCode, locality)
  
}

# Spalten können variieren - kp warum - deshalb mit dplyr::bind_rows das Ganze vereinheitlichen, dann sollte da auch nichts verloren gehen. Fehlende Spalten werden mit NA befüllt (laut Copilot), mal sehen, was dabei rauskommt.
df_data <- dplyr::bind_rows(data_gesammelt)

# Mit rbind ein ganzes DF erstellen

df_data <- do.call(rbind, data_gesammelt)

# Zahl der Zeilen des finalen DF = Anzahl der tatsächlich geladenen Datensätze (sollte = data_info$meta$count sein...)
nrow(df_data)
```


Jetzt wo die Daten heruntergeladen sind, müssen sie noch in eine GIS-handlebare Form übertragen werden -> GeoJSON 
```{r, "Datentransformation & Export"}
#| eval: true
#| echo: true
#| warning: false

# mit dem sf-Paket wird das df zu einem geo-df, reprojeziert und dann als geojson exportiert

geo_df_data <- sf::st_as_sf(df_data,
                            coords = c("decimalLongitude", "decimalLatitude"),
                            crs = 4326 # standart bei GBIF
                            )

geo_df_data_reproj <- sf::st_transform(geo_df_data, crs = 25832) # weil Standart für fast alles in DE

## Speichern als GeoJSON:
dir.create("Data_saved") #erzeugt das Directory für die geojson
st_write(geo_df_data_reproj, "./Data_saved/Species_Data.geojson", driver = "GeoJSON", delete_dsn = TRUE)

```



Um das ganze als Karte darzustellen einmal das ganze in Leaflet werfen:
```{r, "Darstellung mit Leaflet"}
#| eval: true
#| echo: true
#| warning: false

#Karte erstellen
karte_data <- leaflet(geo_df_data) |>
    addTiles() |> # wenn leer, wird standartmäßig OSM verwendet
    addCircleMarkers( # steuert die Marker
      radius = 5,
      color = "green",
      fillColor = "white",
      popup = ~paste("Quelle: ", institutionCode, "<br>",
                                    "Jahr: ", year, "<br>",
                                    "Ort: ", locality)) |> # Label
    setView(lat = 51.16, lng = 10.45, zoom = 6) |> #quasi der "Start" wo die Karte geöffnet wird
    addMiniMap(position = "bottomright", # fügt eine Übersichtskarte/Minimap hinzu
               width = 150,
               height = 150,
               zoomLevelFixed = 4, # fixiert die Karte, damit man da nicht ausversehen rein und rauszoomt
               aimingRectOptions = list(color = "transparent", weight = 0)) # entfernt so eine hässliche BoundingBox die da standartmäßig drin ist. KP, was das soll
  
karte_data # zeigt die Karte an

```














